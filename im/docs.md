<!--
This file was generated by Spark. Do not edit it by hand.
--->
# DSL: Dsl.Root



## root
Root section defining the message type and processes.

### Nested DSLs
 * process(#root-process)
   * state
     * rcv!
       * when!
         * send!
         * broadcast!
         * choice!
           * send!
           * broadcast!
           * mcrl2!
           * state!
         * mcrl2!
         * state!
         * if!
           * then!
             * send!
             * broadcast!
             * state!
           * else!
             * send!
             * broadcast!
             * state!
   * init
     * send!
     * broadcast!
     * choice!
       * send!
       * broadcast!
       * mcrl2!
       * state!
     * if!
       * then!
         * send!
         * broadcast!
         * state!
       * else!
         * send!
         * broadcast!
         * state!
     * state!





### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| `messageType`(#root-messageType){: #root-messageType .spark-required} | `atom \| String.t` |  | The type of messages the system handles. Every message has to be this type. |
| `lossyNetwork`(#root-lossyNetwork){: #root-lossyNetwork } | `boolean` |  | If loosing messages in the network is enabled. |



## root.process
```elixir
process identifier, state, quantity
```


A process that defines commands.

### Nested DSLs
 * state(#root-process-state)
   * rcv!
     * when!
       * send!
       * broadcast!
       * choice!
         * send!
         * broadcast!
         * mcrl2!
         * state!
       * mcrl2!
       * state!
       * if!
         * then!
           * send!
           * broadcast!
           * state!
         * else!
           * send!
           * broadcast!
           * state!
 * init(#root-process-init)
   * send!
   * broadcast!
   * choice!
     * send!
     * broadcast!
     * mcrl2!
     * state!
   * if!
     * then!
       * send!
       * broadcast!
       * state!
     * else!
       * send!
       * broadcast!
       * state!
   * state!




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `identifier`(#root-process-identifier){: #root-process-identifier } | `atom` |  |  |
| `state`(#root-process-state){: #root-process-state } | `%{optional(atom) => {atom, atom \| {atom, atom}}}` |  | State of the process, defined as a map. |
| `quantity`(#root-process-quantity){: #root-process-quantity } | `integer` |  | Number of processes to run. |



## root.process.state
```elixir
state value, args
```


Define a state

### Nested DSLs
 * rcv!(#root-process-state-rcv!)
   * when!
     * send!
     * broadcast!
     * choice!
       * send!
       * broadcast!
       * mcrl2!
       * state!
     * mcrl2!
     * state!
     * if!
       * then!
         * send!
         * broadcast!
         * state!
       * else!
         * send!
         * broadcast!
         * state!




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `value`(#root-process-state-value){: #root-process-state-value } | `atom` |  | State name |
| `args`(#root-process-state-args){: #root-process-state-args } | `%{optional(atom) => {atom, atom} \| atom}` |  |  |



## root.process.state.rcv!
```elixir
rcv! value
```


Receive command.

### Nested DSLs
 * when!(#root-process-state-rcv!-when!)
   * send!
   * broadcast!
   * choice!
     * send!
     * broadcast!
     * mcrl2!
     * state!
   * mcrl2!
   * state!
   * if!
     * then!
       * send!
       * broadcast!
       * state!
     * else!
       * send!
       * broadcast!
       * state!




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `value`(#root-process-state-rcv!-value){: #root-process-state-rcv!-value } | `atom \| {atom \| nil, atom}` |  | Variable name for received value |



## root.process.state.rcv!.when!
```elixir
when! condition
```


Receive case command.

### Nested DSLs
 * send!(#root-process-state-rcv!-when!-send!)
 * broadcast!(#root-process-state-rcv!-when!-broadcast!)
 * choice!(#root-process-state-rcv!-when!-choice!)
   * send!
   * broadcast!
   * mcrl2!
   * state!
 * mcrl2!(#root-process-state-rcv!-when!-mcrl2!)
 * state!(#root-process-state-rcv!-when!-state!)
 * if!(#root-process-state-rcv!-when!-if!)
   * then!
     * send!
     * broadcast!
     * state!
   * else!
     * send!
     * broadcast!
     * state!




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `condition`(#root-process-state-rcv!-when!-condition){: #root-process-state-rcv!-when!-condition } | `any` |  |  |



## root.process.state.rcv!.when!.send!
```elixir
send! to, message
```


Send command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-state-rcv!-when!-send!-to){: #root-process-state-rcv!-when!-send!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-state-rcv!-when!-send!-message){: #root-process-state-rcv!-when!-send!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Send`

## root.process.state.rcv!.when!.broadcast!
```elixir
broadcast! to, message
```


Broadcast command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-state-rcv!-when!-broadcast!-to){: #root-process-state-rcv!-when!-broadcast!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-state-rcv!-when!-broadcast!-message){: #root-process-state-rcv!-when!-broadcast!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Broadcast`

## root.process.state.rcv!.when!.choice!
```elixir
choice! label
```


Non deterministic choice.

### Nested DSLs
 * send!(#root-process-state-rcv!-when!-choice!-send!)
 * broadcast!(#root-process-state-rcv!-when!-choice!-broadcast!)
 * mcrl2!(#root-process-state-rcv!-when!-choice!-mcrl2!)
 * state!(#root-process-state-rcv!-when!-choice!-state!)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `label`(#root-process-state-rcv!-when!-choice!-label){: #root-process-state-rcv!-when!-choice!-label } | `String.t` |  |  |



## root.process.state.rcv!.when!.choice!.send!
```elixir
send! to, message
```


Send command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-state-rcv!-when!-choice!-send!-to){: #root-process-state-rcv!-when!-choice!-send!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-state-rcv!-when!-choice!-send!-message){: #root-process-state-rcv!-when!-choice!-send!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Send`

## root.process.state.rcv!.when!.choice!.broadcast!
```elixir
broadcast! to, message
```


Broadcast command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-state-rcv!-when!-choice!-broadcast!-to){: #root-process-state-rcv!-when!-choice!-broadcast!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-state-rcv!-when!-choice!-broadcast!-message){: #root-process-state-rcv!-when!-choice!-broadcast!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Broadcast`

## root.process.state.rcv!.when!.choice!.mcrl2!
```elixir
mcrl2! state
```


TODO





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `state`(#root-process-state-rcv!-when!-choice!-mcrl2!-state){: #root-process-state-rcv!-when!-choice!-mcrl2!-state } | `atom` |  | Name of the state |






### Introspection

Target: `Commands.Mcrl2State`

## root.process.state.rcv!.when!.choice!.state!
```elixir
state! value, args
```


Change the state





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `value`(#root-process-state-rcv!-when!-choice!-state!-value){: #root-process-state-rcv!-when!-choice!-state!-value } | `atom` |  | State name |
| `args`(#root-process-state-rcv!-when!-choice!-state!-args){: #root-process-state-rcv!-when!-choice!-state!-args } | `any` |  | Arguments to pass to the state |






### Introspection

Target: `Commands.ChangeState`




### Introspection

Target: `Commands.Choice`

## root.process.state.rcv!.when!.mcrl2!
```elixir
mcrl2! state
```


TODO





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `state`(#root-process-state-rcv!-when!-mcrl2!-state){: #root-process-state-rcv!-when!-mcrl2!-state } | `atom` |  | Name of the state |






### Introspection

Target: `Commands.Mcrl2State`

## root.process.state.rcv!.when!.state!
```elixir
state! value, args
```


Change the state





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `value`(#root-process-state-rcv!-when!-state!-value){: #root-process-state-rcv!-when!-state!-value } | `atom` |  | State name |
| `args`(#root-process-state-rcv!-when!-state!-args){: #root-process-state-rcv!-when!-state!-args } | `any` |  | Arguments to pass to the state |






### Introspection

Target: `Commands.ChangeState`

## root.process.state.rcv!.when!.if!
```elixir
if! condition
```


If condition holds, continue to then! child entity, otherwise, continue with else! child entity.

### Nested DSLs
 * then!(#root-process-state-rcv!-when!-if!-then!)
   * send!
   * broadcast!
   * state!
 * else!(#root-process-state-rcv!-when!-if!-else!)
   * send!
   * broadcast!
   * state!




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `condition`(#root-process-state-rcv!-when!-if!-condition){: #root-process-state-rcv!-when!-if!-condition } | `any` |  |  |



## root.process.state.rcv!.when!.if!.then!


If condition holds, continue to then! child entity, otherwise, continue with else! child entity.

### Nested DSLs
 * send!(#root-process-state-rcv!-when!-if!-then!-send!)
 * broadcast!(#root-process-state-rcv!-when!-if!-then!-broadcast!)
 * state!(#root-process-state-rcv!-when!-if!-then!-state!)






## root.process.state.rcv!.when!.if!.then!.send!
```elixir
send! to, message
```


Send command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-state-rcv!-when!-if!-then!-send!-to){: #root-process-state-rcv!-when!-if!-then!-send!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-state-rcv!-when!-if!-then!-send!-message){: #root-process-state-rcv!-when!-if!-then!-send!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Send`

## root.process.state.rcv!.when!.if!.then!.broadcast!
```elixir
broadcast! to, message
```


Broadcast command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-state-rcv!-when!-if!-then!-broadcast!-to){: #root-process-state-rcv!-when!-if!-then!-broadcast!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-state-rcv!-when!-if!-then!-broadcast!-message){: #root-process-state-rcv!-when!-if!-then!-broadcast!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Broadcast`

## root.process.state.rcv!.when!.if!.then!.state!
```elixir
state! value, args
```


Change the state





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `value`(#root-process-state-rcv!-when!-if!-then!-state!-value){: #root-process-state-rcv!-when!-if!-then!-state!-value } | `atom` |  | State name |
| `args`(#root-process-state-rcv!-when!-if!-then!-state!-args){: #root-process-state-rcv!-when!-if!-then!-state!-args } | `any` |  | Arguments to pass to the state |






### Introspection

Target: `Commands.ChangeState`




### Introspection

Target: `Commands.IfThen`

## root.process.state.rcv!.when!.if!.else!


If condition holds, continue to then! child entity, otherwise, continue with else! child entity.

### Nested DSLs
 * send!(#root-process-state-rcv!-when!-if!-else!-send!)
 * broadcast!(#root-process-state-rcv!-when!-if!-else!-broadcast!)
 * state!(#root-process-state-rcv!-when!-if!-else!-state!)






## root.process.state.rcv!.when!.if!.else!.send!
```elixir
send! to, message
```


Send command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-state-rcv!-when!-if!-else!-send!-to){: #root-process-state-rcv!-when!-if!-else!-send!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-state-rcv!-when!-if!-else!-send!-message){: #root-process-state-rcv!-when!-if!-else!-send!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Send`

## root.process.state.rcv!.when!.if!.else!.broadcast!
```elixir
broadcast! to, message
```


Broadcast command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-state-rcv!-when!-if!-else!-broadcast!-to){: #root-process-state-rcv!-when!-if!-else!-broadcast!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-state-rcv!-when!-if!-else!-broadcast!-message){: #root-process-state-rcv!-when!-if!-else!-broadcast!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Broadcast`

## root.process.state.rcv!.when!.if!.else!.state!
```elixir
state! value, args
```


Change the state





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `value`(#root-process-state-rcv!-when!-if!-else!-state!-value){: #root-process-state-rcv!-when!-if!-else!-state!-value } | `atom` |  | State name |
| `args`(#root-process-state-rcv!-when!-if!-else!-state!-args){: #root-process-state-rcv!-when!-if!-else!-state!-args } | `any` |  | Arguments to pass to the state |






### Introspection

Target: `Commands.ChangeState`




### Introspection

Target: `Commands.IfElse`




### Introspection

Target: `Commands.If`




### Introspection

Target: `Commands.ReceiveCase`




### Introspection

Target: `Commands.Receive`




### Introspection

Target: `Commands.State`

## root.process.init


Initial commands

### Nested DSLs
 * send!(#root-process-init-send!)
 * broadcast!(#root-process-init-broadcast!)
 * choice!(#root-process-init-choice!)
   * send!
   * broadcast!
   * mcrl2!
   * state!
 * if!(#root-process-init-if!)
   * then!
     * send!
     * broadcast!
     * state!
   * else!
     * send!
     * broadcast!
     * state!
 * state!(#root-process-init-state!)






## root.process.init.send!
```elixir
send! to, message
```


Send command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-init-send!-to){: #root-process-init-send!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-init-send!-message){: #root-process-init-send!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Send`

## root.process.init.broadcast!
```elixir
broadcast! to, message
```


Broadcast command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-init-broadcast!-to){: #root-process-init-broadcast!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-init-broadcast!-message){: #root-process-init-broadcast!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Broadcast`

## root.process.init.choice!
```elixir
choice! label
```


Non deterministic choice.

### Nested DSLs
 * send!(#root-process-init-choice!-send!)
 * broadcast!(#root-process-init-choice!-broadcast!)
 * mcrl2!(#root-process-init-choice!-mcrl2!)
 * state!(#root-process-init-choice!-state!)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `label`(#root-process-init-choice!-label){: #root-process-init-choice!-label } | `String.t` |  |  |



## root.process.init.choice!.send!
```elixir
send! to, message
```


Send command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-init-choice!-send!-to){: #root-process-init-choice!-send!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-init-choice!-send!-message){: #root-process-init-choice!-send!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Send`

## root.process.init.choice!.broadcast!
```elixir
broadcast! to, message
```


Broadcast command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-init-choice!-broadcast!-to){: #root-process-init-choice!-broadcast!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-init-choice!-broadcast!-message){: #root-process-init-choice!-broadcast!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Broadcast`

## root.process.init.choice!.mcrl2!
```elixir
mcrl2! state
```


TODO





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `state`(#root-process-init-choice!-mcrl2!-state){: #root-process-init-choice!-mcrl2!-state } | `atom` |  | Name of the state |






### Introspection

Target: `Commands.Mcrl2State`

## root.process.init.choice!.state!
```elixir
state! value, args
```


Change the state





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `value`(#root-process-init-choice!-state!-value){: #root-process-init-choice!-state!-value } | `atom` |  | State name |
| `args`(#root-process-init-choice!-state!-args){: #root-process-init-choice!-state!-args } | `any` |  | Arguments to pass to the state |






### Introspection

Target: `Commands.ChangeState`




### Introspection

Target: `Commands.Choice`

## root.process.init.if!
```elixir
if! condition
```


If condition holds, continue to then! child entity, otherwise, continue with else! child entity.

### Nested DSLs
 * then!(#root-process-init-if!-then!)
   * send!
   * broadcast!
   * state!
 * else!(#root-process-init-if!-else!)
   * send!
   * broadcast!
   * state!




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `condition`(#root-process-init-if!-condition){: #root-process-init-if!-condition } | `any` |  |  |



## root.process.init.if!.then!


If condition holds, continue to then! child entity, otherwise, continue with else! child entity.

### Nested DSLs
 * send!(#root-process-init-if!-then!-send!)
 * broadcast!(#root-process-init-if!-then!-broadcast!)
 * state!(#root-process-init-if!-then!-state!)






## root.process.init.if!.then!.send!
```elixir
send! to, message
```


Send command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-init-if!-then!-send!-to){: #root-process-init-if!-then!-send!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-init-if!-then!-send!-message){: #root-process-init-if!-then!-send!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Send`

## root.process.init.if!.then!.broadcast!
```elixir
broadcast! to, message
```


Broadcast command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-init-if!-then!-broadcast!-to){: #root-process-init-if!-then!-broadcast!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-init-if!-then!-broadcast!-message){: #root-process-init-if!-then!-broadcast!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Broadcast`

## root.process.init.if!.then!.state!
```elixir
state! value, args
```


Change the state





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `value`(#root-process-init-if!-then!-state!-value){: #root-process-init-if!-then!-state!-value } | `atom` |  | State name |
| `args`(#root-process-init-if!-then!-state!-args){: #root-process-init-if!-then!-state!-args } | `any` |  | Arguments to pass to the state |






### Introspection

Target: `Commands.ChangeState`




### Introspection

Target: `Commands.IfThen`

## root.process.init.if!.else!


If condition holds, continue to then! child entity, otherwise, continue with else! child entity.

### Nested DSLs
 * send!(#root-process-init-if!-else!-send!)
 * broadcast!(#root-process-init-if!-else!-broadcast!)
 * state!(#root-process-init-if!-else!-state!)






## root.process.init.if!.else!.send!
```elixir
send! to, message
```


Send command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-init-if!-else!-send!-to){: #root-process-init-if!-else!-send!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-init-if!-else!-send!-message){: #root-process-init-if!-else!-send!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Send`

## root.process.init.if!.else!.broadcast!
```elixir
broadcast! to, message
```


Broadcast command.





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `to`(#root-process-init-if!-else!-broadcast!-to){: #root-process-init-if!-else!-broadcast!-to } | `atom \| String.t` |  |  |
| `message`(#root-process-init-if!-else!-broadcast!-message){: #root-process-init-if!-else!-broadcast!-message } | `atom \| String.t \| integer` |  |  |






### Introspection

Target: `Commands.Broadcast`

## root.process.init.if!.else!.state!
```elixir
state! value, args
```


Change the state





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `value`(#root-process-init-if!-else!-state!-value){: #root-process-init-if!-else!-state!-value } | `atom` |  | State name |
| `args`(#root-process-init-if!-else!-state!-args){: #root-process-init-if!-else!-state!-args } | `any` |  | Arguments to pass to the state |






### Introspection

Target: `Commands.ChangeState`




### Introspection

Target: `Commands.IfElse`




### Introspection

Target: `Commands.If`

## root.process.init.state!
```elixir
state! value, args
```


Change the state





### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| `value`(#root-process-init-state!-value){: #root-process-init-state!-value } | `atom` |  | State name |
| `args`(#root-process-init-state!-args){: #root-process-init-state!-args } | `any` |  | Arguments to pass to the state |






### Introspection

Target: `Commands.ChangeState`




### Introspection

Target: `Commands.Init`




### Introspection

Target: `Processes.Process`





<style type="text/css">.spark-required::after { content: "*"; color: red !important; }</style>


process-->init
process-->state

init-->send!
init-->broadcast!
init-->choice!
init-->if!
init-->state!

if!-->ifThen!
if!-->ifElse!

ifThen!-->send!
ifThen!-->broadcast!
ifThen!-->state!

ifElse!-->send!
ifElse!-->broadcast!
ifElse!-->state!

choice!-->send!
choice!-->broadcast!
choice!-->state!
choice!-->mcrl2!

state-->rcv!
rcv!-->when!
when!-->send!
when!-->broadcast!
when!-->choice!
when!-->state!
when!-->mcrl2!
when!-->if!